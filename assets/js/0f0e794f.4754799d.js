(self.webpackChunkreplibyte=self.webpackChunkreplibyte||[]).push([[735],{9542:function(e,t,i){"use strict";i.r(t),i.d(t,{assets:function(){return u},contentTitle:function(){return p},default:function(){return y},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var n=i(7462),a=i(3366),r=(i(7294),i(3905)),o=i(3456),l=["components"],s={sidebar_position:2},p="How Replibyte works",d={unversionedId:"how-replibyte-works",id:"how-replibyte-works",title:"How Replibyte works",description:"RepliByte is built to replicate small and very large databases from one place (source) to the other (destination) with a bridge as",source:"@site/docs/how-replibyte-works.md",sourceDirName:".",slug:"/how-replibyte-works",permalink:"/docs/how-replibyte-works",editUrl:"https://github.com/Qovery/replibyte/webiste/docs/how-replibyte-works.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/introduction"},next:{title:"Installation",permalink:"/docs/getting-started/installation"}},u={},c=[{value:"Design",id:"design",level:2},{value:"Low Memory and CPU footprint",id:"low-memory-and-cpu-footprint",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Index file structure",id:"index-file-structure",level:3}],m={toc:c};function y(e){var t=e.components,i=(0,a.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-replibyte-works"},"How Replibyte works"),(0,r.kt)("p",null,"RepliByte is built to replicate small and very large databases from one place (source) to the other (destination) with a bridge as\nintermediary (bridge). Here is an example of what happens while replicating a PostgreSQL database."),(0,r.kt)(o.Mermaid,{config:{},chart:"sequenceDiagram\n    participant RepliByte\n    participant PostgreSQL (Source)\n    participant AWS S3 (Bridge)\n    PostgreSQL (Source)->>RepliByte: 1. Dump data\n    loop\n        RepliByte->>RepliByte: 2. Subsetting (optional)\n        RepliByte->>RepliByte: 3. Hide or fake sensitive data (optional)\n        RepliByte->>RepliByte: 4. Compress data (optional)\n        RepliByte->>RepliByte: 5. Encrypt data (optional)\n    end\n    RepliByte->>AWS S3 (Bridge): 6. Upload obfuscated dump data\n    RepliByte->>AWS S3 (Bridge): 7. Write index file",mdxType:"Mermaid"}),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"RepliByte connects to the ",(0,r.kt)("em",{parentName:"li"},"PostgreSQL Source")," database and makes a full SQL dump of it."),(0,r.kt)("li",{parentName:"ol"},"RepliByte receives the SQL dump, parse it, and generates random/fake information in real-time."),(0,r.kt)("li",{parentName:"ol"},"RepliByte streams and uploads the modified SQL dump in real-time on AWS S3."),(0,r.kt)("li",{parentName:"ol"},"RepliByte keeps track of the uploaded SQL dump by writing it into an index file.")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Once at least a replica from the source PostgreSQL database is available in the S3 bucket, RepliByte can use and inject it into the\ndestination PostgreSQL database."),(0,r.kt)(o.Mermaid,{chart:"sequenceDiagram\n    participant RepliByte\n    participant PostgreSQL (Destination)\n    participant AWS S3 (Bridge)\n    AWS S3 (Bridge)->>RepliByte: 1. Read index file\n    AWS S3 (Bridge)->>RepliByte: 2. Download dump SQL file\n    loop\n        RepliByte->>RepliByte: 3. Decrypt data (if required)\n        RepliByte->>RepliByte: 4. Uncompress data (if required)\n    end\n    RepliByte->>PostgreSQL (Destination): 5. Restore dump SQL",mdxType:"Mermaid"}),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"RepliByte connects to the S3 bucket and reads the index file to retrieve the latest SQL to download."),(0,r.kt)("li",{parentName:"ol"},"RepliByte downloads the SQL dump in a stream bytes."),(0,r.kt)("li",{parentName:"ol"},"RepliByte restores the SQL dump in the destination PostgreSQL database in real-time.")),(0,r.kt)("h2",{id:"design"},"Design"),(0,r.kt)("h3",{id:"low-memory-and-cpu-footprint"},"Low Memory and CPU footprint"),(0,r.kt)("p",null,"Written in Rust, RepliByte can run with 512 MB of RAM and 1 CPU to replicate 1 TB of data (we are working on a benchmark). RepliByte\nreplicate the data in a stream of bytes and does not store anything on a local disk."),(0,r.kt)("h3",{id:"limitations"},"Limitations"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Tested with PostgreSQL 13 and 14. It should work with prior versions."),(0,r.kt)("li",{parentName:"ul"},"RepliByte as not been designed to run multiple backups targeting the same Bridge. The Index File does not manage concurrent write (ATM).")),(0,r.kt)("h3",{id:"index-file-structure"},"Index file structure"),(0,r.kt)("p",null,"An index file describe the structure of your backups and all of them."),(0,r.kt)("p",null,"Here is the manifest file that you can find at the root of your target ",(0,r.kt)("inlineCode",{parentName:"p"},"Bridge")," (E.g: S3)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "backups": [\n    {\n      "size": 1024000,\n      "directory_name": "backup-{epoch timestamp}",\n      "created_at": "epoch timestamp",\n      "compressed": true,\n      "encrypted": true\n    }\n  ]\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"size")," is in bytes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"created_at")," is an epoch timestamp in millis")))}y.isMDXComponent=!0},1748:function(e,t,i){var n={"./locale":9234,"./locale.js":9234};function a(e){var t=r(e);return i(t)}function r(e){if(!i.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}a.keys=function(){return Object.keys(n)},a.resolve=r,e.exports=a,a.id=1748}}]);